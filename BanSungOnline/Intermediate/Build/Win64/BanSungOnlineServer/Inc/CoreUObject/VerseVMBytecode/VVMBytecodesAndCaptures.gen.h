// Copyright Epic Games, Inc. All Rights Reserved.

// WARNING: This code is autogenerated by VerseVMBytecodeGenerator.cs. Do not edit directly

#pragma once

// IWYU pragma: private, include "VVMBytecodesAndCaptures.h"

namespace Verse {
struct FOpAdd : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Add;
    static constexpr bool bHasJumps = false;

    FOpAdd(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpAdd) >= 8);

struct FOpSub : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Sub;
    static constexpr bool bHasJumps = false;

    FOpSub(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpSub) >= 8);

struct FOpMul : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Mul;
    static constexpr bool bHasJumps = false;

    FOpMul(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpMul) >= 8);

struct FOpDiv : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Div;
    static constexpr bool bHasJumps = false;

    FOpDiv(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpDiv) >= 8);

struct FOpMod : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Mod;
    static constexpr bool bHasJumps = false;

    FOpMod(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpMod) >= 8);

struct FOpMutableAdd : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::MutableAdd;
    static constexpr bool bHasJumps = false;

    FOpMutableAdd(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpMutableAdd) >= 8);

struct FOpNeg : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Source;

    static constexpr EOpcode StaticOpcode = EOpcode::Neg;
    static constexpr bool bHasJumps = false;

    FOpNeg(FRegisterIndex Dest, FValueOperand Source)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Source(Source)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Source, TEXT("Source"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNeg) >= 8);

struct FOpQuery : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Source;

    static constexpr EOpcode StaticOpcode = EOpcode::Query;
    static constexpr bool bHasJumps = false;

    FOpQuery(FRegisterIndex Dest, FValueOperand Source)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Source(Source)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Source, TEXT("Source"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpQuery) >= 8);

struct FOpErr : public FOp
{

    static constexpr EOpcode StaticOpcode = EOpcode::Err;
    static constexpr bool bHasJumps = false;

    FOpErr()
        : FOp(StaticOpcode)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpErr) >= 8);

struct FOpMove : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Source;

    static constexpr EOpcode StaticOpcode = EOpcode::Move;
    static constexpr bool bHasJumps = false;

    FOpMove(FRegisterIndex Dest, FValueOperand Source)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Source(Source)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Source, TEXT("Source"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpMove) >= 8);

struct FOpReset : public FOp
{
    FRegisterIndex Dest;

    static constexpr EOpcode StaticOpcode = EOpcode::Reset;
    static constexpr bool bHasJumps = false;

    FOpReset(FRegisterIndex Dest)
        : FOp(StaticOpcode)
        , Dest(Dest)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::ClobberDef, Dest, TEXT("Dest"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpReset) >= 8);

struct FOpJump : public FOp
{
    FLabelOffset JumpOffset;

    static constexpr EOpcode StaticOpcode = EOpcode::Jump;
    static constexpr bool bHasJumps = true;

    FOpJump(FLabelOffset JumpOffset)
        : FOp(StaticOpcode)
        , JumpOffset(JumpOffset)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
        Function(JumpOffset, TEXT("JumpOffset"));
    }
};
static_assert(alignof(FOpJump) >= 8);

struct FOpJumpIfInitialized : public FOp
{
    FValueOperand Source;
    FLabelOffset JumpOffset;

    static constexpr EOpcode StaticOpcode = EOpcode::JumpIfInitialized;
    static constexpr bool bHasJumps = true;

    FOpJumpIfInitialized(FValueOperand Source, FLabelOffset JumpOffset)
        : FOp(StaticOpcode)
        , Source(Source)
        , JumpOffset(JumpOffset)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Source, TEXT("Source"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
        Function(JumpOffset, TEXT("JumpOffset"));
    }
};
static_assert(alignof(FOpJumpIfInitialized) >= 8);

struct FOpSwitch : public FOp
{
    FValueOperand Which;
    TOperandRange<FLabelOffset> JumpOffsets;

    static constexpr EOpcode StaticOpcode = EOpcode::Switch;
    static constexpr bool bHasJumps = true;

    FOpSwitch(FValueOperand Which, TOperandRange<FLabelOffset> JumpOffsets)
        : FOp(StaticOpcode)
        , Which(Which)
        , JumpOffsets(JumpOffsets)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Which, TEXT("Which"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
        Function(JumpOffsets, TEXT("JumpOffsets"));
    }
};
static_assert(alignof(FOpSwitch) >= 8);

struct FOpBeginFailureContext : public FOp
{
    FLabelOffset OnFailure;

    static constexpr EOpcode StaticOpcode = EOpcode::BeginFailureContext;
    static constexpr bool bHasJumps = true;

    FOpBeginFailureContext(FLabelOffset OnFailure)
        : FOp(StaticOpcode)
        , OnFailure(OnFailure)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
        Function(OnFailure, TEXT("OnFailure"));
    }
};
static_assert(alignof(FOpBeginFailureContext) >= 8);

struct FOpEndFailureContext : public FOp
{
    FLabelOffset Done;

    static constexpr EOpcode StaticOpcode = EOpcode::EndFailureContext;
    static constexpr bool bHasJumps = true;

    FOpEndFailureContext(FLabelOffset Done)
        : FOp(StaticOpcode)
        , Done(Done)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
        Function(Done, TEXT("Done"));
    }
};
static_assert(alignof(FOpEndFailureContext) >= 8);

struct FOpBeginTask : public FOp
{
    FRegisterIndex Dest;
    bool bAttached;
    FLabelOffset OnYield;

    static constexpr EOpcode StaticOpcode = EOpcode::BeginTask;
    static constexpr bool bHasJumps = true;

    FOpBeginTask(FRegisterIndex Dest, bool bAttached, FLabelOffset OnYield)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , bAttached(bAttached)
        , OnYield(OnYield)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
        Function(OnYield, TEXT("OnYield"));
    }
};
static_assert(alignof(FOpBeginTask) >= 8);

struct FOpEndTask : public FOp
{
    FRegisterIndex Write;
    FValueOperand Signal;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::EndTask;
    static constexpr bool bHasJumps = false;

    FOpEndTask(FRegisterIndex Write, FValueOperand Signal, FValueOperand Value)
        : FOp(StaticOpcode)
        , Write(Write)
        , Signal(Signal)
        , Value(Value)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::ClobberDef, Write, TEXT("Write"));
        Function(EOperandRole::Use, Signal, TEXT("Signal"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpEndTask) >= 8);

struct FOpNewSemaphore : public FOp
{
    FRegisterIndex Dest;

    static constexpr EOpcode StaticOpcode = EOpcode::NewSemaphore;
    static constexpr bool bHasJumps = false;

    FOpNewSemaphore(FRegisterIndex Dest)
        : FOp(StaticOpcode)
        , Dest(Dest)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNewSemaphore) >= 8);

struct FOpWaitSemaphore : public FOp
{
    FValueOperand Source;
    int32 Count;

    static constexpr EOpcode StaticOpcode = EOpcode::WaitSemaphore;
    static constexpr bool bHasJumps = false;

    FOpWaitSemaphore(FValueOperand Source, int32 Count)
        : FOp(StaticOpcode)
        , Source(Source)
        , Count(Count)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Source, TEXT("Source"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpWaitSemaphore) >= 8);

struct FOpCall : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Callee;
    TOperandRange<FValueOperand> Arguments;

    static constexpr EOpcode StaticOpcode = EOpcode::Call;
    static constexpr bool bHasJumps = false;

    FOpCall(FRegisterIndex Dest, FValueOperand Callee, TOperandRange<FValueOperand> Arguments)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Callee(Callee)
        , Arguments(Arguments)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Callee, TEXT("Callee"));
        Function(EOperandRole::Use, Arguments, TEXT("Arguments"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpCall) >= 8);

struct FOpCallNamed : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Callee;
    TOperandRange<FValueOperand> Arguments;
    TOperandRange<TWriteBarrier<VUniqueString>> NamedArguments;
    TOperandRange<FValueOperand> NamedArgumentVals;

    static constexpr EOpcode StaticOpcode = EOpcode::CallNamed;
    static constexpr bool bHasJumps = false;

    FOpCallNamed(FRegisterIndex Dest, FValueOperand Callee, TOperandRange<FValueOperand> Arguments, TOperandRange<TWriteBarrier<VUniqueString>> NamedArguments, TOperandRange<FValueOperand> NamedArgumentVals)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Callee(Callee)
        , Arguments(Arguments)
        , NamedArguments(NamedArguments)
        , NamedArgumentVals(NamedArgumentVals)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Callee, TEXT("Callee"));
        Function(EOperandRole::Use, Arguments, TEXT("Arguments"));
        Function(EOperandRole::Immediate, NamedArguments, TEXT("NamedArguments"));
        Function(EOperandRole::Use, NamedArgumentVals, TEXT("NamedArgumentVals"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpCallNamed) >= 8);

struct FOpReturn : public FOp
{
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::Return;
    static constexpr bool bHasJumps = false;

    FOpReturn(FValueOperand Value)
        : FOp(StaticOpcode)
        , Value(Value)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Value, TEXT("Value"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpReturn) >= 8);

struct FOpResumeUnwind : public FOp
{

    static constexpr EOpcode StaticOpcode = EOpcode::ResumeUnwind;
    static constexpr bool bHasJumps = false;

    FOpResumeUnwind()
        : FOp(StaticOpcode)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpResumeUnwind) >= 8);

struct FOpNewVar : public FOp
{
    FRegisterIndex Dest;

    static constexpr EOpcode StaticOpcode = EOpcode::NewVar;
    static constexpr bool bHasJumps = false;

    FOpNewVar(FRegisterIndex Dest)
        : FOp(StaticOpcode)
        , Dest(Dest)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNewVar) >= 8);

struct FOpVarGet : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Var;

    static constexpr EOpcode StaticOpcode = EOpcode::VarGet;
    static constexpr bool bHasJumps = false;

    FOpVarGet(FRegisterIndex Dest, FValueOperand Var)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Var(Var)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Var, TEXT("Var"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpVarGet) >= 8);

struct FOpVarSet : public FOp
{
    FValueOperand Var;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::VarSet;
    static constexpr bool bHasJumps = false;

    FOpVarSet(FValueOperand Var, FValueOperand Value)
        : FOp(StaticOpcode)
        , Var(Var)
        , Value(Value)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Var, TEXT("Var"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpVarSet) >= 8);

struct FOpFreeze : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::Freeze;
    static constexpr bool bHasJumps = false;

    FOpFreeze(FRegisterIndex Dest, FValueOperand Value)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Value(Value)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpFreeze) >= 8);

struct FOpMelt : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::Melt;
    static constexpr bool bHasJumps = false;

    FOpMelt(FRegisterIndex Dest, FValueOperand Value)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Value(Value)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpMelt) >= 8);

struct FOpLength : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Container;

    static constexpr EOpcode StaticOpcode = EOpcode::Length;
    static constexpr bool bHasJumps = false;

    FOpLength(FRegisterIndex Dest, FValueOperand Container)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Container(Container)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Container, TEXT("Container"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpLength) >= 8);

struct FOpCallSet : public FOp
{
    FValueOperand Container;
    FValueOperand Index;
    FValueOperand ValueToSet;

    static constexpr EOpcode StaticOpcode = EOpcode::CallSet;
    static constexpr bool bHasJumps = false;

    FOpCallSet(FValueOperand Container, FValueOperand Index, FValueOperand ValueToSet)
        : FOp(StaticOpcode)
        , Container(Container)
        , Index(Index)
        , ValueToSet(ValueToSet)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Container, TEXT("Container"));
        Function(EOperandRole::Use, Index, TEXT("Index"));
        Function(EOperandRole::Use, ValueToSet, TEXT("ValueToSet"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpCallSet) >= 8);

struct FOpNewArray : public FOp
{
    FRegisterIndex Dest;
    TOperandRange<FValueOperand> Values;

    static constexpr EOpcode StaticOpcode = EOpcode::NewArray;
    static constexpr bool bHasJumps = false;

    FOpNewArray(FRegisterIndex Dest, TOperandRange<FValueOperand> Values)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Values(Values)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Values, TEXT("Values"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNewArray) >= 8);

struct FOpNewMutableArray : public FOp
{
    FRegisterIndex Dest;
    TOperandRange<FValueOperand> Values;

    static constexpr EOpcode StaticOpcode = EOpcode::NewMutableArray;
    static constexpr bool bHasJumps = false;

    FOpNewMutableArray(FRegisterIndex Dest, TOperandRange<FValueOperand> Values)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Values(Values)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Values, TEXT("Values"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNewMutableArray) >= 8);

struct FOpNewMutableArrayWithCapacity : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Size;

    static constexpr EOpcode StaticOpcode = EOpcode::NewMutableArrayWithCapacity;
    static constexpr bool bHasJumps = false;

    FOpNewMutableArrayWithCapacity(FRegisterIndex Dest, FValueOperand Size)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Size(Size)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Size, TEXT("Size"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNewMutableArrayWithCapacity) >= 8);

struct FOpArrayAdd : public FOp
{
    FValueOperand Container;
    FValueOperand ValueToAdd;

    static constexpr EOpcode StaticOpcode = EOpcode::ArrayAdd;
    static constexpr bool bHasJumps = false;

    FOpArrayAdd(FValueOperand Container, FValueOperand ValueToAdd)
        : FOp(StaticOpcode)
        , Container(Container)
        , ValueToAdd(ValueToAdd)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Container, TEXT("Container"));
        Function(EOperandRole::Use, ValueToAdd, TEXT("ValueToAdd"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpArrayAdd) >= 8);

struct FOpInPlaceMakeImmutable : public FOp
{
    FValueOperand Container;

    static constexpr EOpcode StaticOpcode = EOpcode::InPlaceMakeImmutable;
    static constexpr bool bHasJumps = false;

    FOpInPlaceMakeImmutable(FValueOperand Container)
        : FOp(StaticOpcode)
        , Container(Container)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Container, TEXT("Container"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpInPlaceMakeImmutable) >= 8);

struct FOpNewOption : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::NewOption;
    static constexpr bool bHasJumps = false;

    FOpNewOption(FRegisterIndex Dest, FValueOperand Value)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Value(Value)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNewOption) >= 8);

struct FOpNewMap : public FOp
{
    FRegisterIndex Dest;
    TOperandRange<FValueOperand> Keys;
    TOperandRange<FValueOperand> Values;

    static constexpr EOpcode StaticOpcode = EOpcode::NewMap;
    static constexpr bool bHasJumps = false;

    FOpNewMap(FRegisterIndex Dest, TOperandRange<FValueOperand> Keys, TOperandRange<FValueOperand> Values)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Keys(Keys)
        , Values(Values)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Keys, TEXT("Keys"));
        Function(EOperandRole::Use, Values, TEXT("Values"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNewMap) >= 8);

struct FOpMapKey : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Map;
    FValueOperand Index;

    static constexpr EOpcode StaticOpcode = EOpcode::MapKey;
    static constexpr bool bHasJumps = false;

    FOpMapKey(FRegisterIndex Dest, FValueOperand Map, FValueOperand Index)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Map(Map)
        , Index(Index)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Map, TEXT("Map"));
        Function(EOperandRole::Use, Index, TEXT("Index"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpMapKey) >= 8);

struct FOpMapValue : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Map;
    FValueOperand Index;

    static constexpr EOpcode StaticOpcode = EOpcode::MapValue;
    static constexpr bool bHasJumps = false;

    FOpMapValue(FRegisterIndex Dest, FValueOperand Map, FValueOperand Index)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Map(Map)
        , Index(Index)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Map, TEXT("Map"));
        Function(EOperandRole::Use, Index, TEXT("Index"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpMapValue) >= 8);

struct FOpNewClass : public FOp
{
    FRegisterIndex Dest;
    TWriteBarrier<VPackage> Package;
    TWriteBarrier<VArray> Name;
    TWriteBarrier<VArray> UEMangledName;
    TWriteBarrier<VValue> ImportStruct;
    TOperandRange<FValueOperand> Inherited;
    TWriteBarrier<VConstructor> Constructor;
    bool bNative;
    VClass::EKind ClassKind;

    static constexpr EOpcode StaticOpcode = EOpcode::NewClass;
    static constexpr bool bHasJumps = false;

    FOpNewClass(FAccessContext Context, FRegisterIndex Dest, VPackage& Package, VArray& Name, VArray& UEMangledName, VValue ImportStruct, TOperandRange<FValueOperand> Inherited, VConstructor& Constructor, bool bNative, VClass::EKind ClassKind)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Package(Context, Package)
        , Name(Context, Name)
        , UEMangledName(Context, UEMangledName)
        , ImportStruct(Context, ImportStruct)
        , Inherited(Inherited)
        , Constructor(Context, Constructor)
        , bNative(bNative)
        , ClassKind(ClassKind)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Immediate, Package, TEXT("Package"));
        Function(EOperandRole::Immediate, Name, TEXT("Name"));
        Function(EOperandRole::Immediate, UEMangledName, TEXT("UEMangledName"));
        Function(EOperandRole::Immediate, ImportStruct, TEXT("ImportStruct"));
        Function(EOperandRole::Use, Inherited, TEXT("Inherited"));
        Function(EOperandRole::Immediate, Constructor, TEXT("Constructor"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNewClass) >= 8);

struct FOpNewObject : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Class;
    TWriteBarrier<VUniqueStringSet> Fields;
    TOperandRange<FValueOperand> Values;

    static constexpr EOpcode StaticOpcode = EOpcode::NewObject;
    static constexpr bool bHasJumps = false;

    FOpNewObject(FAccessContext Context, FRegisterIndex Dest, FValueOperand Class, VUniqueStringSet& Fields, TOperandRange<FValueOperand> Values)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Class(Class)
        , Fields(Context, Fields)
        , Values(Values)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Class, TEXT("Class"));
        Function(EOperandRole::Immediate, Fields, TEXT("Fields"));
        Function(EOperandRole::Use, Values, TEXT("Values"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNewObject) >= 8);

struct FOpLoadField : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Object;
    TWriteBarrier<VUniqueString> Name;

    static constexpr EOpcode StaticOpcode = EOpcode::LoadField;
    static constexpr bool bHasJumps = false;

    FOpLoadField(FAccessContext Context, FRegisterIndex Dest, FValueOperand Object, VUniqueString& Name)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Object(Object)
        , Name(Context, Name)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Object, TEXT("Object"));
        Function(EOperandRole::Immediate, Name, TEXT("Name"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpLoadField) >= 8);

struct FOpLoadFieldFromSuper : public FOp
{
    FRegisterIndex Dest;
    FValueOperand Scope;
    FValueOperand Self;
    TWriteBarrier<VUniqueString> Name;

    static constexpr EOpcode StaticOpcode = EOpcode::LoadFieldFromSuper;
    static constexpr bool bHasJumps = false;

    FOpLoadFieldFromSuper(FAccessContext Context, FRegisterIndex Dest, FValueOperand Scope, FValueOperand Self, VUniqueString& Name)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , Scope(Scope)
        , Self(Self)
        , Name(Context, Name)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Scope, TEXT("Scope"));
        Function(EOperandRole::Use, Self, TEXT("Self"));
        Function(EOperandRole::Immediate, Name, TEXT("Name"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpLoadFieldFromSuper) >= 8);

struct FOpUnifyField : public FOp
{
    FValueOperand Object;
    TWriteBarrier<VUniqueString> Name;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::UnifyField;
    static constexpr bool bHasJumps = false;

    FOpUnifyField(FAccessContext Context, FValueOperand Object, VUniqueString& Name, FValueOperand Value)
        : FOp(StaticOpcode)
        , Object(Object)
        , Name(Context, Name)
        , Value(Value)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Object, TEXT("Object"));
        Function(EOperandRole::Immediate, Name, TEXT("Name"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpUnifyField) >= 8);

struct FOpSetField : public FOp
{
    FValueOperand Object;
    TWriteBarrier<VUniqueString> Name;
    FValueOperand Value;

    static constexpr EOpcode StaticOpcode = EOpcode::SetField;
    static constexpr bool bHasJumps = false;

    FOpSetField(FAccessContext Context, FValueOperand Object, VUniqueString& Name, FValueOperand Value)
        : FOp(StaticOpcode)
        , Object(Object)
        , Name(Context, Name)
        , Value(Value)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Object, TEXT("Object"));
        Function(EOperandRole::Immediate, Name, TEXT("Name"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpSetField) >= 8);

struct FOpNeq : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Neq;
    static constexpr bool bHasJumps = false;

    FOpNeq(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpNeq) >= 8);

struct FOpLt : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Lt;
    static constexpr bool bHasJumps = false;

    FOpLt(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpLt) >= 8);

struct FOpLte : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Lte;
    static constexpr bool bHasJumps = false;

    FOpLte(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpLte) >= 8);

struct FOpGt : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Gt;
    static constexpr bool bHasJumps = false;

    FOpGt(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpGt) >= 8);

struct FOpGte : public FOp
{
    FRegisterIndex Dest;
    FValueOperand LeftSource;
    FValueOperand RightSource;

    static constexpr EOpcode StaticOpcode = EOpcode::Gte;
    static constexpr bool bHasJumps = false;

    FOpGte(FRegisterIndex Dest, FValueOperand LeftSource, FValueOperand RightSource)
        : FOp(StaticOpcode)
        , Dest(Dest)
        , LeftSource(LeftSource)
        , RightSource(RightSource)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }

    template <typename FunctionType>
    void ForEachJump(FunctionType&& Function)
    {
    }
};
static_assert(alignof(FOpGte) >= 8);

struct FAddSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FAddSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FAddSuspensionCaptures(FAccessContext Context, const FAddSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

struct FSubSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FSubSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FSubSuspensionCaptures(FAccessContext Context, const FSubSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

struct FMulSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FMulSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FMulSuspensionCaptures(FAccessContext Context, const FMulSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

struct FDivSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FDivSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FDivSuspensionCaptures(FAccessContext Context, const FDivSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

struct FModSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FModSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FModSuspensionCaptures(FAccessContext Context, const FModSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

struct FMutableAddSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FMutableAddSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FMutableAddSuspensionCaptures(FAccessContext Context, const FMutableAddSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

struct FNegSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Source;  

    FNegSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Source)
        : Dest(Context, Dest)
        , Source(Context, Source)
    {}

    FNegSuspensionCaptures(FAccessContext Context, const FNegSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Source(Context, Other.Source.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Source, TEXT("Source"));
    }
};

struct FQuerySuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Source;  

    FQuerySuspensionCaptures(FAccessContext Context, VValue Dest, VValue Source)
        : Dest(Context, Dest)
        , Source(Context, Source)
    {}

    FQuerySuspensionCaptures(FAccessContext Context, const FQuerySuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Source(Context, Other.Source.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Source, TEXT("Source"));
    }
};

struct FCallSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Callee;  
    TArray<TWriteBarrier<VValue>> Arguments;
    TWriteBarrier<VValue> EffectToken;
    TWriteBarrier<VValue> ReturnEffectToken;

    FCallSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Callee, TArray<TWriteBarrier<VValue>>&& Arguments, VValue EffectToken, VValue ReturnEffectToken)
        : Dest(Context, Dest)
        , Callee(Context, Callee)
        , Arguments(MoveTemp(Arguments))
        , EffectToken(Context, EffectToken)
        , ReturnEffectToken(Context, ReturnEffectToken)
    {}

    FCallSuspensionCaptures(FAccessContext Context, const FCallSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Callee(Context, Other.Callee.Get())
        , Arguments(Other.Arguments)
        , EffectToken(Context, Other.EffectToken.Get())
        , ReturnEffectToken(Context, Other.ReturnEffectToken.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Callee, TEXT("Callee"));
        Function(EOperandRole::Use, Arguments, TEXT("Arguments"));
        Function(EOperandRole::Use, EffectToken, TEXT("EffectToken"));
        Function(EOperandRole::UnifyDef, ReturnEffectToken, TEXT("ReturnEffectToken"));
    }
};

struct FCallNamedSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Callee;  
    TArray<TWriteBarrier<VValue>> Arguments;
    TArray<TWriteBarrier<VUniqueString>> NamedArguments;
    TArray<TWriteBarrier<VValue>> NamedArgumentVals;
    TWriteBarrier<VValue> EffectToken;
    TWriteBarrier<VValue> ReturnEffectToken;

    FCallNamedSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Callee, TArray<TWriteBarrier<VValue>>&& Arguments, TArray<TWriteBarrier<VUniqueString>>&& NamedArguments, TArray<TWriteBarrier<VValue>>&& NamedArgumentVals, VValue EffectToken, VValue ReturnEffectToken)
        : Dest(Context, Dest)
        , Callee(Context, Callee)
        , Arguments(MoveTemp(Arguments))
        , NamedArguments(MoveTemp(NamedArguments))
        , NamedArgumentVals(MoveTemp(NamedArgumentVals))
        , EffectToken(Context, EffectToken)
        , ReturnEffectToken(Context, ReturnEffectToken)
    {}

    FCallNamedSuspensionCaptures(FAccessContext Context, const FCallNamedSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Callee(Context, Other.Callee.Get())
        , Arguments(Other.Arguments)
        , NamedArguments(Other.NamedArguments)
        , NamedArgumentVals(Other.NamedArgumentVals)
        , EffectToken(Context, Other.EffectToken.Get())
        , ReturnEffectToken(Context, Other.ReturnEffectToken.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Callee, TEXT("Callee"));
        Function(EOperandRole::Use, Arguments, TEXT("Arguments"));
        Function(EOperandRole::Immediate, NamedArguments, TEXT("NamedArguments"));
        Function(EOperandRole::Use, NamedArgumentVals, TEXT("NamedArgumentVals"));
        Function(EOperandRole::Use, EffectToken, TEXT("EffectToken"));
        Function(EOperandRole::UnifyDef, ReturnEffectToken, TEXT("ReturnEffectToken"));
    }
};

struct FVarGetSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Var;  
    TWriteBarrier<VValue> EffectToken;

    FVarGetSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Var, VValue EffectToken)
        : Dest(Context, Dest)
        , Var(Context, Var)
        , EffectToken(Context, EffectToken)
    {}

    FVarGetSuspensionCaptures(FAccessContext Context, const FVarGetSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Var(Context, Other.Var.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Var, TEXT("Var"));
        Function(EOperandRole::Use, EffectToken, TEXT("EffectToken"));
    }
};

struct FVarSetSuspensionCaptures
{
    TWriteBarrier<VValue> Var;  
    TWriteBarrier<VValue> Value;  
    TWriteBarrier<VValue> EffectToken;

    FVarSetSuspensionCaptures(FAccessContext Context, VValue Var, VValue Value, VValue EffectToken)
        : Var(Context, Var)
        , Value(Context, Value)
        , EffectToken(Context, EffectToken)
    {}

    FVarSetSuspensionCaptures(FAccessContext Context, const FVarSetSuspensionCaptures& Other)
        : Var(Context, Other.Var.Get())
        , Value(Context, Other.Value.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Var, TEXT("Var"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
        Function(EOperandRole::Use, EffectToken, TEXT("EffectToken"));
    }
};

struct FFreezeSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Value;  
    TWriteBarrier<VValue> EffectToken;

    FFreezeSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Value, VValue EffectToken)
        : Dest(Context, Dest)
        , Value(Context, Value)
        , EffectToken(Context, EffectToken)
    {}

    FFreezeSuspensionCaptures(FAccessContext Context, const FFreezeSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Value(Context, Other.Value.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
        Function(EOperandRole::Use, EffectToken, TEXT("EffectToken"));
    }
};

struct FMeltSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Value;  
    TWriteBarrier<VValue> EffectToken;

    FMeltSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Value, VValue EffectToken)
        : Dest(Context, Dest)
        , Value(Context, Value)
        , EffectToken(Context, EffectToken)
    {}

    FMeltSuspensionCaptures(FAccessContext Context, const FMeltSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Value(Context, Other.Value.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
        Function(EOperandRole::Use, EffectToken, TEXT("EffectToken"));
    }
};

struct FLengthSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Container;  

    FLengthSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Container)
        : Dest(Context, Dest)
        , Container(Context, Container)
    {}

    FLengthSuspensionCaptures(FAccessContext Context, const FLengthSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Container(Context, Other.Container.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Container, TEXT("Container"));
    }
};

struct FCallSetSuspensionCaptures
{
    TWriteBarrier<VValue> Container;  
    TWriteBarrier<VValue> Index;  
    TWriteBarrier<VValue> ValueToSet;  
    TWriteBarrier<VValue> EffectToken;

    FCallSetSuspensionCaptures(FAccessContext Context, VValue Container, VValue Index, VValue ValueToSet, VValue EffectToken)
        : Container(Context, Container)
        , Index(Context, Index)
        , ValueToSet(Context, ValueToSet)
        , EffectToken(Context, EffectToken)
    {}

    FCallSetSuspensionCaptures(FAccessContext Context, const FCallSetSuspensionCaptures& Other)
        : Container(Context, Other.Container.Get())
        , Index(Context, Other.Index.Get())
        , ValueToSet(Context, Other.ValueToSet.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Container, TEXT("Container"));
        Function(EOperandRole::Use, Index, TEXT("Index"));
        Function(EOperandRole::Use, ValueToSet, TEXT("ValueToSet"));
        Function(EOperandRole::Use, EffectToken, TEXT("EffectToken"));
    }
};

struct FNewArraySuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TArray<TWriteBarrier<VValue>> Values;

    FNewArraySuspensionCaptures(FAccessContext Context, VValue Dest, TArray<TWriteBarrier<VValue>>&& Values)
        : Dest(Context, Dest)
        , Values(MoveTemp(Values))
    {}

    FNewArraySuspensionCaptures(FAccessContext Context, const FNewArraySuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Values(Other.Values)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Values, TEXT("Values"));
    }
};

struct FNewMutableArraySuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TArray<TWriteBarrier<VValue>> Values;

    FNewMutableArraySuspensionCaptures(FAccessContext Context, VValue Dest, TArray<TWriteBarrier<VValue>>&& Values)
        : Dest(Context, Dest)
        , Values(MoveTemp(Values))
    {}

    FNewMutableArraySuspensionCaptures(FAccessContext Context, const FNewMutableArraySuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Values(Other.Values)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Values, TEXT("Values"));
    }
};

struct FNewMutableArrayWithCapacitySuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Size;  

    FNewMutableArrayWithCapacitySuspensionCaptures(FAccessContext Context, VValue Dest, VValue Size)
        : Dest(Context, Dest)
        , Size(Context, Size)
    {}

    FNewMutableArrayWithCapacitySuspensionCaptures(FAccessContext Context, const FNewMutableArrayWithCapacitySuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Size(Context, Other.Size.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Size, TEXT("Size"));
    }
};

struct FArrayAddSuspensionCaptures
{
    TWriteBarrier<VValue> Container;  
    TWriteBarrier<VValue> ValueToAdd;  
    TWriteBarrier<VValue> EffectToken;

    FArrayAddSuspensionCaptures(FAccessContext Context, VValue Container, VValue ValueToAdd, VValue EffectToken)
        : Container(Context, Container)
        , ValueToAdd(Context, ValueToAdd)
        , EffectToken(Context, EffectToken)
    {}

    FArrayAddSuspensionCaptures(FAccessContext Context, const FArrayAddSuspensionCaptures& Other)
        : Container(Context, Other.Container.Get())
        , ValueToAdd(Context, Other.ValueToAdd.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Container, TEXT("Container"));
        Function(EOperandRole::Use, ValueToAdd, TEXT("ValueToAdd"));
        Function(EOperandRole::Use, EffectToken, TEXT("EffectToken"));
    }
};

struct FInPlaceMakeImmutableSuspensionCaptures
{
    TWriteBarrier<VValue> Container;  

    FInPlaceMakeImmutableSuspensionCaptures(FAccessContext Context, VValue Container)
        : Container(Context, Container)
    {}

    FInPlaceMakeImmutableSuspensionCaptures(FAccessContext Context, const FInPlaceMakeImmutableSuspensionCaptures& Other)
        : Container(Context, Other.Container.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Container, TEXT("Container"));
    }
};

struct FNewOptionSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Value;  

    FNewOptionSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Value)
        : Dest(Context, Dest)
        , Value(Context, Value)
    {}

    FNewOptionSuspensionCaptures(FAccessContext Context, const FNewOptionSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Value(Context, Other.Value.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
    }
};

struct FNewMapSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TArray<TWriteBarrier<VValue>> Keys;
    TArray<TWriteBarrier<VValue>> Values;

    FNewMapSuspensionCaptures(FAccessContext Context, VValue Dest, TArray<TWriteBarrier<VValue>>&& Keys, TArray<TWriteBarrier<VValue>>&& Values)
        : Dest(Context, Dest)
        , Keys(MoveTemp(Keys))
        , Values(MoveTemp(Values))
    {}

    FNewMapSuspensionCaptures(FAccessContext Context, const FNewMapSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Keys(Other.Keys)
        , Values(Other.Values)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Keys, TEXT("Keys"));
        Function(EOperandRole::Use, Values, TEXT("Values"));
    }
};

struct FMapKeySuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Map;  
    TWriteBarrier<VValue> Index;  

    FMapKeySuspensionCaptures(FAccessContext Context, VValue Dest, VValue Map, VValue Index)
        : Dest(Context, Dest)
        , Map(Context, Map)
        , Index(Context, Index)
    {}

    FMapKeySuspensionCaptures(FAccessContext Context, const FMapKeySuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Map(Context, Other.Map.Get())
        , Index(Context, Other.Index.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Map, TEXT("Map"));
        Function(EOperandRole::Use, Index, TEXT("Index"));
    }
};

struct FMapValueSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Map;  
    TWriteBarrier<VValue> Index;  

    FMapValueSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Map, VValue Index)
        : Dest(Context, Dest)
        , Map(Context, Map)
        , Index(Context, Index)
    {}

    FMapValueSuspensionCaptures(FAccessContext Context, const FMapValueSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Map(Context, Other.Map.Get())
        , Index(Context, Other.Index.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Map, TEXT("Map"));
        Function(EOperandRole::Use, Index, TEXT("Index"));
    }
};

struct FNewClassSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VPackage> Package;
    TWriteBarrier<VArray> Name;
    TWriteBarrier<VArray> UEMangledName;
    TWriteBarrier<VValue> ImportStruct;
    TArray<TWriteBarrier<VValue>> Inherited;
    TWriteBarrier<VConstructor> Constructor;
    bool bNative;
    VClass::EKind ClassKind;

    FNewClassSuspensionCaptures(FAccessContext Context, VValue Dest, VPackage& Package, VArray& Name, VArray& UEMangledName, VValue ImportStruct, TArray<TWriteBarrier<VValue>>&& Inherited, VConstructor& Constructor, bool bNative, VClass::EKind ClassKind)
        : Dest(Context, Dest)
        , Package(Context, Package)
        , Name(Context, Name)
        , UEMangledName(Context, UEMangledName)
        , ImportStruct(Context, ImportStruct)
        , Inherited(MoveTemp(Inherited))
        , Constructor(Context, Constructor)
        , bNative(bNative)
        , ClassKind(ClassKind)
    {}

    FNewClassSuspensionCaptures(FAccessContext Context, const FNewClassSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Package(Context, Other.Package.Get())
        , Name(Context, Other.Name.Get())
        , UEMangledName(Context, Other.UEMangledName.Get())
        , ImportStruct(Context, Other.ImportStruct.Get())
        , Inherited(Other.Inherited)
        , Constructor(Context, Other.Constructor.Get())
        , bNative(Other.bNative)
        , ClassKind(Other.ClassKind)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Immediate, Package, TEXT("Package"));
        Function(EOperandRole::Immediate, Name, TEXT("Name"));
        Function(EOperandRole::Immediate, UEMangledName, TEXT("UEMangledName"));
        Function(EOperandRole::Immediate, ImportStruct, TEXT("ImportStruct"));
        Function(EOperandRole::Use, Inherited, TEXT("Inherited"));
        Function(EOperandRole::Immediate, Constructor, TEXT("Constructor"));
    }
};

struct FNewObjectSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Class;  
    TWriteBarrier<VUniqueStringSet> Fields;
    TArray<TWriteBarrier<VValue>> Values;

    FNewObjectSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Class, VUniqueStringSet& Fields, TArray<TWriteBarrier<VValue>>&& Values)
        : Dest(Context, Dest)
        , Class(Context, Class)
        , Fields(Context, Fields)
        , Values(MoveTemp(Values))
    {}

    FNewObjectSuspensionCaptures(FAccessContext Context, const FNewObjectSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Class(Context, Other.Class.Get())
        , Fields(Context, Other.Fields.Get())
        , Values(Other.Values)
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Class, TEXT("Class"));
        Function(EOperandRole::Immediate, Fields, TEXT("Fields"));
        Function(EOperandRole::Use, Values, TEXT("Values"));
    }
};

struct FLoadFieldSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Object;  
    TWriteBarrier<VUniqueString> Name;

    FLoadFieldSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Object, VUniqueString& Name)
        : Dest(Context, Dest)
        , Object(Context, Object)
        , Name(Context, Name)
    {}

    FLoadFieldSuspensionCaptures(FAccessContext Context, const FLoadFieldSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Object(Context, Other.Object.Get())
        , Name(Context, Other.Name.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Object, TEXT("Object"));
        Function(EOperandRole::Immediate, Name, TEXT("Name"));
    }
};

struct FLoadFieldFromSuperSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> Scope;  
    TWriteBarrier<VValue> Self;  
    TWriteBarrier<VUniqueString> Name;

    FLoadFieldFromSuperSuspensionCaptures(FAccessContext Context, VValue Dest, VValue Scope, VValue Self, VUniqueString& Name)
        : Dest(Context, Dest)
        , Scope(Context, Scope)
        , Self(Context, Self)
        , Name(Context, Name)
    {}

    FLoadFieldFromSuperSuspensionCaptures(FAccessContext Context, const FLoadFieldFromSuperSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , Scope(Context, Other.Scope.Get())
        , Self(Context, Other.Self.Get())
        , Name(Context, Other.Name.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, Scope, TEXT("Scope"));
        Function(EOperandRole::Use, Self, TEXT("Self"));
        Function(EOperandRole::Immediate, Name, TEXT("Name"));
    }
};

struct FUnifyFieldSuspensionCaptures
{
    TWriteBarrier<VValue> Object;  
    TWriteBarrier<VUniqueString> Name;
    TWriteBarrier<VValue> Value;  

    FUnifyFieldSuspensionCaptures(FAccessContext Context, VValue Object, VUniqueString& Name, VValue Value)
        : Object(Context, Object)
        , Name(Context, Name)
        , Value(Context, Value)
    {}

    FUnifyFieldSuspensionCaptures(FAccessContext Context, const FUnifyFieldSuspensionCaptures& Other)
        : Object(Context, Other.Object.Get())
        , Name(Context, Other.Name.Get())
        , Value(Context, Other.Value.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Object, TEXT("Object"));
        Function(EOperandRole::Immediate, Name, TEXT("Name"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
    }
};

struct FSetFieldSuspensionCaptures
{
    TWriteBarrier<VValue> Object;  
    TWriteBarrier<VUniqueString> Name;
    TWriteBarrier<VValue> Value;  
    TWriteBarrier<VValue> EffectToken;

    FSetFieldSuspensionCaptures(FAccessContext Context, VValue Object, VUniqueString& Name, VValue Value, VValue EffectToken)
        : Object(Context, Object)
        , Name(Context, Name)
        , Value(Context, Value)
        , EffectToken(Context, EffectToken)
    {}

    FSetFieldSuspensionCaptures(FAccessContext Context, const FSetFieldSuspensionCaptures& Other)
        : Object(Context, Other.Object.Get())
        , Name(Context, Other.Name.Get())
        , Value(Context, Other.Value.Get())
        , EffectToken(Context, Other.EffectToken.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::Use, Object, TEXT("Object"));
        Function(EOperandRole::Immediate, Name, TEXT("Name"));
        Function(EOperandRole::Use, Value, TEXT("Value"));
        Function(EOperandRole::Use, EffectToken, TEXT("EffectToken"));
    }
};

struct FNeqSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FNeqSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FNeqSuspensionCaptures(FAccessContext Context, const FNeqSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

struct FLtSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FLtSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FLtSuspensionCaptures(FAccessContext Context, const FLtSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

struct FLteSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FLteSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FLteSuspensionCaptures(FAccessContext Context, const FLteSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

struct FGtSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FGtSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FGtSuspensionCaptures(FAccessContext Context, const FGtSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

struct FGteSuspensionCaptures
{
    TWriteBarrier<VValue> Dest;  
    TWriteBarrier<VValue> LeftSource;  
    TWriteBarrier<VValue> RightSource;  

    FGteSuspensionCaptures(FAccessContext Context, VValue Dest, VValue LeftSource, VValue RightSource)
        : Dest(Context, Dest)
        , LeftSource(Context, LeftSource)
        , RightSource(Context, RightSource)
    {}

    FGteSuspensionCaptures(FAccessContext Context, const FGteSuspensionCaptures& Other)
        : Dest(Context, Other.Dest.Get())
        , LeftSource(Context, Other.LeftSource.Get())
        , RightSource(Context, Other.RightSource.Get())
    {}

    template <typename FunctionType>
    void ForEachOperand(FunctionType&& Function)
    {
        Function(EOperandRole::UnifyDef, Dest, TEXT("Dest"));
        Function(EOperandRole::Use, LeftSource, TEXT("LeftSource"));
        Function(EOperandRole::Use, RightSource, TEXT("RightSource"));
    }
};

} // namespace Verse
